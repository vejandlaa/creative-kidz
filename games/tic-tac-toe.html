<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ultimate Monster Tic-Tac-Toe</title>
    <style>
        :root {
            --bg-color: #e3f2fd;
            --grid-color: #0288d1;
            --cell-size: 100px; /* Slightly smaller to fit side panel */
            --focus-outline: 8px solid #ffeb3b;
        }

        body {
            font-family: 'Comic Sans MS', 'Chalkboard SE', sans-serif;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            min-height: 100vh; margin: 0; background-color: var(--bg-color);
            padding: 10px; box-sizing: border-box; user-select: none; overflow: hidden;
        }

        /* TV Focus */
        .tv-focused {
            outline: var(--focus-outline) !important;
            transform: scale(1.05); z-index: 100;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        }

        h1 { color: #01579b; margin: 0 0 10px 0; text-shadow: 2px 2px white; text-align: center; font-size: clamp(1.5rem, 4vw, 2.5rem); }

        /* Main Container */
        .container {
            background: white; padding: 20px; border-radius: 25px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3); border: 6px solid var(--grid-color);
            max-width: 900px; width: 98%; text-align: center; position: relative;
        }

        .hidden { display: none !important; }

        /* Buttons */
        .btn {
            padding: 12px 24px; font-size: 1.1rem; border: none; border-radius: 50px;
            cursor: pointer; font-family: inherit; font-weight: bold; color: white;
            margin: 8px; transition: transform 0.1s; outline: none; width: 80%; max-width: 280px;
        }
        .btn:active { transform: scale(0.95); opacity: 0.8; }
        .btn-blue { background-color: #03a9f4; }
        .btn-red { background-color: #ef5350; }
        .btn-green { background-color: #66bb6a; }
        .btn-purple { background-color: #ab47bc; }

        /* --- GAME LAYOUT (SIDE BY SIDE) --- */
        .game-layout {
            display: flex; flex-direction: row; align-items: flex-start; justify-content: center; gap: 20px;
        }
        /* Mobile Layout */
        @media (max-width: 700px) {
            .game-layout { flex-direction: column; align-items: center; }
            :root { --cell-size: 80px; }
        }

        /* The Board Section */
        .game-main { display: flex; flex-direction: column; align-items: center; }

        /* The Side Collection Panel */
        .side-collection {
            background: #fff9c4; border: 4px dashed #fbc02d; border-radius: 15px;
            padding: 10px; width: 160px; min-height: 350px;
            display: flex; flex-direction: column; align-items: center;
        }
        @media (max-width: 700px) {
            .side-collection {
                width: 90%; min-height: auto; flex-direction: row;
                overflow-x: auto; padding: 5px; border-width: 2px;
            }
        }

        .collection-title { font-weight: bold; color: #f57f17; margin-bottom: 10px; }

        .mini-toy {
            background: white; border: 2px solid #ddd; border-radius: 10px;
            margin: 5px; padding: 5px; width: 50px; height: 50px;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.5rem; position: relative;
        }
        .mini-toy-count {
            position: absolute; bottom: -5px; right: -5px; background: red;
            color: white; font-size: 0.7rem; padding: 2px 5px; border-radius: 10px;
            font-weight: bold;
        }

        /* Avatar Grid */
        .avatar-grid { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin: 15px 0; }
        .avatar-option {
            width: 80px; height: 80px; border: 4px solid #eee; border-radius: 20px;
            display: flex; justify-content: center; align-items: center;
            background: #f9f9f9; transition: transform 0.2s; cursor: pointer;
        }
        .draw-new-btn { background: #fff; border: 4px dashed #333; font-size: 2.5rem; color: #333; }

        /* Drawing Studio */
        #drawing-area { display: flex; flex-direction: column; align-items: center; }
        .giggle-bot-area {
            position: relative; margin-bottom: 5px; width: 100%; display: flex;
            justify-content: center; align-items: flex-end; height: 60px;
        }
        .bot-avatar { font-size: 3rem; margin-right: 10px; }
        .speech-bubble {
            background: #333; color: white; padding: 8px 15px;
            border-radius: 20px 20px 20px 0; font-size: 0.9rem;
            max-width: 300px; display: flex; align-items: center;
        }

        .canvas-wrapper {
            position: relative; border-radius: 15px; overflow: hidden;
            border: 4px solid #333; background: white; cursor: crosshair;
        }
        #tv-cursor {
            width: 15px; height: 15px; background: rgba(255, 0, 0, 0.8);
            border: 2px solid white; border-radius: 50%;
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 10;
            display: none; box-shadow: 0 0 5px black;
        }
        .tools-panel { background: #eee; width: 100%; padding: 5px; border-radius: 15px; margin-top: 10px; }
        .palette { display: flex; gap: 8px; justify-content: center; margin-bottom: 5px; flex-wrap: wrap;}
        .color-swatch {
            width: 30px; height: 30px; border-radius: 50%;
            border: 3px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .color-swatch.active { transform: scale(1.2); border-color: #333; }

        /* Game Board */
        .scoreboard { display: flex; justify-content: space-around; width: 100%; margin-bottom: 10px; background: #fff; padding: 5px; border-radius: 15px; border: 2px solid #ccc; }
        .score-val { font-size: 1.5rem; font-weight: 800; color: #ef5350; }
        .board {
            display: grid; grid-template-columns: repeat(3, var(--cell-size));
            grid-template-rows: repeat(3, var(--cell-size));
            gap: 8px; background-color: var(--grid-color);
            border: 8px solid var(--grid-color); border-radius: 20px;
            margin: 0 auto;
        }
        .cell { background-color: #fff; width: var(--cell-size); height: var(--cell-size); display: flex; align-items: center; justify-content: center; position: relative; border-radius: 15px; overflow: visible; }

        /* --- MONSTER CSS (ALL 4 RESTORED) --- */
        .avatar-wrapper { width: 80%; height: 80%; position: relative; display: flex; justify-content: center; align-items: center; z-index: 5; }
        .custom-drawing { width: 100%; height: 100%; object-fit: contain; filter: drop-shadow(0 4px 2px rgba(0,0,0,0.3)); }

        /* 1. Slime */
        .mon-slime { width: 70%; height: 60%; background: #a3cf15; border-radius: 50% 50% 40% 40%; border: 3px solid #6d8c00; position: relative; }
        .mon-slime::before { content: ''; position: absolute; top: 20%; left: 25%; width: 30%; height: 40%; background: white; border: 2px solid black; border-radius: 50%; }
        .mon-slime::after { content: ''; position: absolute; top: 30%; left: 40%; width: 10%; height: 10%; background: black; border-radius: 50%; }

        /* 2. Derpy */
        .mon-derpy { width: 60%; height: 60%; background: #29b6f6; border-radius: 10px; border: 3px solid #0277bd; position: relative; }
        .mon-derpy::before { content: ''; position: absolute; top: 25%; left: 20%; width: 15%; height: 15%; background: white; border: 2px solid black; border-radius: 50%; box-shadow: 25px 0 0 white, 25px 0 0 2px black; }
        .mon-derpy::after { content: ''; position: absolute; bottom: 20%; left: 45%; width: 15%; height: 25%; background: #f48fb1; border: 2px solid black; border-radius: 0 0 10px 10px; }

        /* 3. Silly */
        .mon-silly { width: 60%; height: 70%; background: #ffa726; border-radius: 50%; border: 3px solid #ef6c00; position: relative; }
        .mon-silly .eye { width: 12px; height: 12px; background: white; border: 2px solid black; border-radius: 50%; position: absolute; }
        .mon-silly::after { content: ''; width: 30px; height: 10px; border-bottom: 3px solid black; border-radius: 50%; position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%); }

        /* 4. Grumpy */
        .mon-grumpy { width: 70%; height: 60%; background: #ab47bc; border: 3px solid #7b1fa2; position: relative; clip-path: polygon(0% 10%, 10% 0%, 20% 10%, 30% 0%, 40% 10%, 50% 0%, 60% 10%, 70% 0%, 80% 10%, 90% 0%, 100% 10%, 100% 100%, 0% 100%); }
        .mon-grumpy::before { content:''; position: absolute; top: 25%; left: 20%; width: 15px; height: 5px; background: white; border: 2px solid black; box-shadow: 30px 0 0 white, 30px 0 0 2px black; transform: rotate(15deg); }
        .mon-grumpy::after { content:''; position: absolute; top: 25%; right: 20%; width: 15px; height: 5px; transform: rotate(-15deg); }

        /* --- ANIMATIONS --- */
        .winner-anim { animation: happyBounce 0.8s infinite; }
        @keyframes happyBounce { 0% { transform: translateY(0); } 50% { transform: translateY(-15px); } }

        /* Prize Drop */
        .prize-popup {
            position: absolute; top: -50px; left: 50%; transform: translateX(-50%);
            z-index: 20; font-size: 3rem;
            animation: prizeReveal 1.5s forwards ease-out;
        }
        @keyframes prizeReveal {
            0% { top: -100px; opacity: 0; transform: translateX(-50%) scale(0.5); }
            50% { top: 10px; opacity: 1; transform: translateX(-50%) scale(1.2); }
            70% { transform: translateX(-50%) scale(0.9) rotate(10deg); }
            80% { transform: translateX(-50%) scale(1.1) rotate(-10deg); }
            100% { top: 0px; opacity: 1; transform: translateX(-50%) scale(1); }
        }

        /* Loser Effects */
        .sinking-anim { animation: sinkIntoWater 3s forwards; }
        @keyframes sinkIntoWater { 100% { transform: translateY(50px); opacity: 0; } }
        .puddle { position: absolute; bottom: 0px; width: 90%; height: 25%; background: #29b6f6; border-radius: 50%; z-index: 1; animation: growPuddle 0.5s forwards; }
        @keyframes growPuddle { from { transform: scale(0); } to { transform: scale(1); } }
        .rain-cloud { position: absolute; top: -45px; left: 50%; transform: translateX(-50%); font-size: 3rem; z-index: 10; }
        .rain-drop { position: absolute; width: 3px; height: 15px; background: #29b6f6; top: -10px; z-index: 9; animation: rainFall 0.6s linear infinite; }
        @keyframes rainFall { to { transform: translateY(120px); opacity: 0; } }
        .tear { position: absolute; width: 8px; height: 8px; background: #0288d1; border-radius: 0 50% 50% 50%; transform: rotate(45deg); top: 40%; z-index: 10; opacity: 0; animation: cryStream 1s infinite linear; }
        @keyframes cryStream { 0% { top: 40%; opacity: 1; } 100% { top: 80%; opacity: 0; } }

    </style>
</head>
<body>

<h1 id="main-title">Monster TV</h1>

<div class="container" id="app-container">

    <div id="view-mode" class="view-section">
        <h2>Who is playing?</h2>
        <button class="btn btn-blue nav-item" onclick="setMode('pvc')" tabindex="0">1 Player (vs Computer)</button>
        <br>
        <button class="btn btn-red nav-item" onclick="setMode('pvp')" tabindex="0">2 Players</button>
        <p style="font-size: 0.9rem; color: #666; margin-top: 20px;">üì∫ Arrow Keys to Move, Enter to Select</p>
    </div>

    <div id="view-avatar" class="view-section hidden">
        <h2 id="avatar-title">Player 1: Pick!</h2>
        <div class="avatar-grid">
            <div class="avatar-option nav-item draw-new-btn" onclick="openDrawingTool()" tabindex="0">üé®</div>
            <div class="avatar-option nav-item" onclick="selectPreMade('slime')" tabindex="0"><div class="avatar-wrapper"><div class="mon-slime"></div></div></div>
            <div class="avatar-option nav-item" onclick="selectPreMade('derpy')" tabindex="0"><div class="avatar-wrapper"><div class="mon-derpy"></div></div></div>
            <div class="avatar-option nav-item" onclick="selectPreMade('silly')" tabindex="0"><div class="avatar-wrapper"><div class="mon-silly"><div class="eye" style="top:15px; left:10px;"></div><div class="eye" style="top:10px; left:35px;"></div><div class="eye" style="top:15px; left:60px;"></div></div></div></div>
            <div class="avatar-option nav-item" onclick="selectPreMade('grumpy')" tabindex="0"><div class="avatar-wrapper"><div class="mon-grumpy"></div></div></div>
        </div>
    </div>

    <div id="view-turn" class="view-section hidden">
        <h2>Who goes first?</h2>
        <div style="display: flex; flex-direction: column; align-items: center; gap: 5px;">
            <button class="btn btn-green nav-item" onclick="chooseTurn('p1')" tabindex="0">Me / Player 1</button>
            <button class="btn btn-red nav-item" onclick="chooseTurn('p2')" tabindex="0" id="btn-p2-start">Computer</button>
            <button class="btn btn-purple nav-item" onclick="chooseTurn('random')" tabindex="0">Random üé≤</button>
        </div>
    </div>

    <div id="view-drawing" class="view-section hidden">
        <div class="giggle-bot-area">
            <div class="bot-avatar" id="bot-face">ü§®</div>
            <div class="speech-bubble" id="bot-text">Impress me.</div>
        </div>
        <div class="canvas-wrapper" id="canvas-container">
            <canvas id="paintCanvas" width="280" height="280"></canvas>
            <div id="tv-cursor"></div>
        </div>
        <div class="tools-panel">
            <div class="palette">
                <div class="color-swatch nav-item active" style="background:#000000" onclick="setColor('black', this)" tabindex="0"></div>
                <div class="color-swatch nav-item" style="background:#795548" onclick="setColor('brown', this)" tabindex="0"></div>
                <div class="color-swatch nav-item" style="background:#ff4757" onclick="setColor('red', this)" tabindex="0"></div>
                <div class="color-swatch nav-item" style="background:#2ed573" onclick="setColor('green', this)" tabindex="0"></div>
                <div class="color-swatch nav-item" style="background:#3742fa" onclick="setColor('blue', this)" tabindex="0"></div>
            </div>
        </div>
        <div style="margin-top: 10px;">
            <button class="btn btn-red nav-item" onclick="clearCanvas()" tabindex="0">Clear</button>
            <button class="btn btn-green nav-item" onclick="saveDrawing()" tabindex="0">Finish!</button>
        </div>
    </div>

    <div id="view-game" class="view-section hidden">

        <div class="game-layout">
            <div class="game-main">
                <div class="scoreboard">
                    <div class="score-box"><span id="p1-name">P1</span><br><span class="score-val" id="score-p1">0</span></div>
                    <div class="score-box"><span id="p2-name">P2</span><br><span class="score-val" id="score-p2">0</span></div>
                </div>
                <h3 id="status-text">Start!</h3>
                <div class="board" id="board"></div>

                <div style="margin-top:10px;">
                    <button class="btn btn-blue nav-item" onclick="restartGame()" tabindex="0">Play Again</button>
                    <button class="btn btn-red nav-item" onclick="location.reload()" tabindex="0">Exit</button>
                </div>
            </div>

            <div class="side-collection">
                <div class="collection-title">My Toys üéÅ</div>
                <div id="mini-shelf-grid" style="display:flex; flex-wrap:wrap; justify-content:center;">
                    <div style="font-size:0.8rem; color:#888;">Win to collect!</div>
                </div>
            </div>
        </div>

    </div>

</div>

<script>
    /* --- STATE --- */
    const state = {
        mode: '', turn: 'p1', setupPlayer: 1,
        p1: { html: '' }, p2: { html: '' },
        board: Array(9).fill(''), active: false, scores: { p1: 0, p2: 0 },
        collection: { 'bear':0, 'dino':0, 'uni':0, 'robot':0, 'duck':0, 'car':0 }
    };

    const premades = {
        'slime': '<div class="mon-slime"></div>',
        'derpy': '<div class="mon-derpy"></div>',
        'silly': '<div class="mon-silly"><div class="eye" style="top:15px; left:10px;"></div><div class="eye" style="top:10px; left:35px;"></div><div class="eye" style="top:15px; left:60px;"></div></div>',
        'grumpy': '<div class="mon-grumpy"></div>'
    };

    const toyList = [
        { id: 'bear', icon: 'üß∏', name: 'Teddy' },
        { id: 'dino', icon: 'ü¶ñ', name: 'T-Rex' },
        { id: 'uni', icon: 'ü¶Ñ', name: 'Sparkles' },
        { id: 'robot', icon: 'ü§ñ', name: 'Beep' },
        { id: 'duck', icon: 'ü¶Ü', name: 'Quack' },
        { id: 'car', icon: 'üèéÔ∏è', name: 'Zoom' }
    ];

    /* --- TV NAVIGATION --- */
    let currentFocusIndex = 0, navItems = [];
    function updateNavList() {
        navItems = Array.from(document.querySelectorAll('.view-section:not(.hidden) .nav-item'));
        currentFocusIndex = 0; if(navItems.length > 0) setFocus(0);
    }
    function setFocus(index) {
        navItems.forEach(el => el.classList.remove('tv-focused'));
        if(navItems[index]) { navItems[index].classList.add('tv-focused'); navItems[index].focus(); }
    }
    document.addEventListener('keydown', (e) => {
        if(navItems.length === 0 && !isDrawingMode) return;
        if(!document.getElementById('view-drawing').classList.contains('hidden')) {
            handleTvDrawing(e);
            if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) return;
        }
        if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
            currentFocusIndex = (currentFocusIndex + 1) % navItems.length; setFocus(currentFocusIndex);
        } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
            currentFocusIndex = (currentFocusIndex - 1 + navItems.length) % navItems.length; setFocus(currentFocusIndex);
        } else if (e.key === 'Enter') {
            navItems[currentFocusIndex].click();
        }
    });

    /* --- VIEW MANAGEMENT --- */
    function switchView(id) {
        document.querySelectorAll('.view-section').forEach(el => el.classList.add('hidden'));
        document.getElementById(id).classList.remove('hidden');
        setTimeout(updateNavList, 100);
    }
    function setMode(m) {
        state.mode = m; state.setupPlayer = 1; switchView('view-avatar');
        document.getElementById('avatar-title').innerText = "Player 1: Pick!";
        document.getElementById('btn-p2-start').innerText = m === 'pvc' ? "Computer" : "Player 2";
    }
    function selectPreMade(key) { finishSetup(`<div class="avatar-wrapper">${premades[key]}</div>`); }
    function finishSetup(html) {
        if(state.setupPlayer === 1) {
            state.p1.html = html;
            if(state.mode === 'pvc') {
                // Bot picks random avatar
                const keys = Object.keys(premades);
                state.p2.html = `<div class="avatar-wrapper">${premades[keys[Math.floor(Math.random() * keys.length)]]}</div>`;
                document.getElementById('p2-name').innerText = "Bot";
                switchView('view-turn'); // Go to turn select
            } else {
                state.setupPlayer = 2; switchView('view-avatar');
                document.getElementById('avatar-title').innerText = "Player 2: Pick!";
            }
        } else {
            state.p2.html = html;
            switchView('view-turn'); // Go to turn select
        }
    }
    function chooseTurn(choice) {
        state.turn = (choice === 'random') ? (Math.random() < 0.5 ? 'p1' : 'p2') : choice;
        startGame();
    }

    /* --- DRAWING (SASSY BOT) --- */
    const canvas = document.getElementById('paintCanvas');
    const ctx = canvas.getContext('2d');
    const tvCursor = document.getElementById('tv-cursor');
    const botText = document.getElementById('bot-text');
    const botFace = document.getElementById('bot-face');
    let isDrawingMode = false, tvBrushActive = false, tvX = 140, tvY = 140, currentColor = 'black';

    function openDrawingTool() { switchView('view-drawing'); ctx.clearRect(0,0,300,300); isDrawingMode = true; tvCursor.style.display = 'block'; updateTvCursor(); }
    function setColor(c, btn) {
        currentColor = c; document.querySelectorAll('.color-swatch').forEach(el => el.classList.remove('active')); btn.classList.add('active');
        if(c === 'brown') { botFace.innerText = "ü§¢"; botText.innerText = "Is that poop?"; }
        else if(c === 'green') { botFace.innerText = "ü§ß"; botText.innerText = "Boogers?"; }
        else { botFace.innerText = "ü§î"; botText.innerText = "Interesting choice."; }
    }

    let mouseDrawing = false;
    canvas.addEventListener('mousedown', (e) => startStroke(e.offsetX, e.offsetY));
    canvas.addEventListener('mousemove', (e) => { if(mouseDrawing) drawTo(e.offsetX, e.offsetY); });
    canvas.addEventListener('mouseup', endStroke);
    canvas.addEventListener('touchstart', (e) => { const r = canvas.getBoundingClientRect(); startStroke(e.touches[0].clientX - r.left, e.touches[0].clientY - r.top); });
    canvas.addEventListener('touchmove', (e) => { const r = canvas.getBoundingClientRect(); if(mouseDrawing) drawTo(e.touches[0].clientX - r.left, e.touches[0].clientY - r.top); e.preventDefault(); });
    canvas.addEventListener('touchend', endStroke);

    function startStroke(x, y) { mouseDrawing = true; ctx.beginPath(); ctx.moveTo(x, y); ctx.lineWidth = 10; ctx.lineCap = 'round'; ctx.strokeStyle = currentColor; }
    function drawTo(x, y) { ctx.lineTo(x, y); ctx.stroke(); }
    function endStroke() { mouseDrawing = false; ctx.beginPath(); }

    function handleTvDrawing(e) {
        const speed = 15; let moved = false;
        if(e.key === 'ArrowUp') { tvY -= speed; moved = true; }
        if(e.key === 'ArrowDown') { tvY += speed; moved = true; }
        if(e.key === 'ArrowLeft') { tvX -= speed; moved = true; }
        if(e.key === 'ArrowRight') { tvX += speed; moved = true; }
        tvX = Math.max(0, Math.min(280, tvX)); tvY = Math.max(0, Math.min(280, tvY));
        if(moved) { updateTvCursor(); if(tvBrushActive) { ctx.lineTo(tvX, tvY); ctx.stroke(); } else { ctx.moveTo(tvX, tvY); } }
        if(e.key === 'Enter') {
            const focused = document.querySelector('.tv-focused');
            if(!focused || focused.tagName !== 'BUTTON' && !focused.classList.contains('color-swatch')) {
                tvBrushActive = !tvBrushActive;
                tvCursor.style.backgroundColor = tvBrushActive ? currentColor : 'transparent';
                tvCursor.style.border = tvBrushActive ? 'none' : '2px solid red';
                if(tvBrushActive) { ctx.beginPath(); ctx.lineWidth = 10; ctx.lineCap = 'round'; ctx.strokeStyle = currentColor; ctx.moveTo(tvX, tvY); } else { ctx.beginPath(); }
            }
        }
    }
    function updateTvCursor() { tvCursor.style.left = tvX + 'px'; tvCursor.style.top = tvY + 'px'; }
    function clearCanvas() { ctx.clearRect(0, 0, 300, 300); botFace.innerText = "üôÑ"; botText.innerText = "Finally, it was ugly."; }
    function saveDrawing() { isDrawingMode = false; finishSetup(`<div class="avatar-wrapper"><img src="${canvas.toDataURL()}" class="custom-drawing"></div>`); }

    /* --- GAME LOGIC --- */
    const lines = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];

    function startGame() {
        switchView('view-game'); state.board.fill(''); state.active = true;
        renderBoard(); updateStatusText();
        if(state.mode === 'pvc' && state.turn === 'p2') setTimeout(computerMove, 800);
    }
    function restartGame() {
        state.board.fill(''); state.active = true;
        renderBoard(); updateStatusText();
        // Same player starts or alternate? Let's just reset current turn for now or keep random
        if(state.mode === 'pvc' && state.turn === 'p2') setTimeout(computerMove, 800);
    }
    function updateStatusText() {
        let name = state.turn === 'p1' ? "Player 1" : (state.mode === 'pvc' ? "Bot" : "Player 2");
        document.getElementById('status-text').innerText = `${name}'s Turn!`;
    }
    function renderBoard() {
        const el = document.getElementById('board'); el.innerHTML = '';
        state.board.forEach((cell, i) => {
            const div = document.createElement('div'); div.className = 'cell nav-item'; div.tabIndex = 0;
            div.onclick = () => move(i);
            div.addEventListener('keydown', (e) => { if(e.key === 'Enter') move(i); });
            if(cell === 'p1') div.innerHTML = state.p1.html;
            if(cell === 'p2') div.innerHTML = state.p2.html;
            if(cell !== '') div.classList.add('taken');
            el.appendChild(div);
        });
        updateNavList();
    }

    function move(i) {
        if(!state.active || state.board[i] !== '') return;
        state.board[i] = state.turn;
        renderBoard();
        if(checkWin(state.turn, state.board)) { endGame(state.turn); return; }
        if(!state.board.includes('')) { endGame('draw'); return; }
        state.turn = state.turn === 'p1' ? 'p2' : 'p1';
        updateStatusText();
        if(state.mode === 'pvc' && state.turn === 'p2') setTimeout(computerMove, 500);
    }

    /* --- AI --- */
    function computerMove() {
        if(!state.active) return;
        if (Math.random() < 0.1) {
            const empty = state.board.map((v, i) => v === '' ? i : null).filter(v => v !== null);
            move(empty[Math.floor(Math.random() * empty.length)]);
        } else { move(getBestMove([...state.board])); }
    }
    function getBestMove(board) {
        let bestScore = -Infinity, bestMove = -1;
        for(let i = 0; i < 9; i++) {
            if(board[i] === '') {
                board[i] = 'p2'; let score = minimax(board, 0, false); board[i] = '';
                if(score > bestScore) { bestScore = score; bestMove = i; }
            }
        }
        return bestMove;
    }
    function minimax(board, depth, isMaximizing) {
        if (checkWin('p2', board)) return 10 - depth;
        if (checkWin('p1', board)) return depth - 10;
        if (!board.includes('')) return 0;
        if (isMaximizing) {
            let bestScore = -Infinity;
            for (let i = 0; i < 9; i++) { if (board[i] === '') { board[i] = 'p2'; bestScore = Math.max(bestScore, minimax(board, depth + 1, false)); board[i] = ''; } }
            return bestScore;
        } else {
            let bestScore = Infinity;
            for (let i = 0; i < 9; i++) { if (board[i] === '') { board[i] = 'p1'; bestScore = Math.min(bestScore, minimax(board, depth + 1, true)); board[i] = ''; } }
            return bestScore;
        }
    }
    function checkWin(p, currentBoard) { return lines.some(l => currentBoard[l[0]]===p && currentBoard[l[1]]===p && currentBoard[l[2]]===p); }

    /* --- PRIZE & ENDGAME --- */
    function endGame(winner) {
        state.active = false;
        const status = document.getElementById('status-text');
        const cells = document.querySelectorAll('.cell');

        if(winner === 'draw') {
            status.innerText = "It's a Draw! üåßÔ∏è";
            cells.forEach(c => { if(c.innerHTML) applyLoserStyle(c); });
        } else {
            const winnerName = winner === 'p1' ? "Player 1" : (state.mode === 'pvc' ? "Bot" : "Player 2");
            state.scores[winner]++;
            document.getElementById(`score-${winner}`).innerText = state.scores[winner];

            // Award Prize only if P1 wins or PvP
            let prize = null;
            if(winner === 'p1' || state.mode === 'pvp') {
                prize = toyList[Math.floor(Math.random() * toyList.length)];
                state.collection[prize.id]++;
                renderSideShelf();
            }

            status.innerText = prize ? `${winnerName} won a ${prize.name}!` : `${winnerName} Wins!`;

            cells.forEach((c, i) => {
                if(state.board[i] === winner) applyWinnerStyle(c, prize);
                else if(state.board[i]) applyLoserStyle(c);
            });
        }
    }

    function renderSideShelf() {
        const container = document.getElementById('mini-shelf-grid');
        container.innerHTML = '';
        let hasItems = false;
        toyList.forEach(toy => {
            const count = state.collection[toy.id];
            if(count > 0) {
                hasItems = true;
                const div = document.createElement('div');
                div.className = 'mini-toy';
                div.innerHTML = `${toy.icon} <div class="mini-toy-count">${count}</div>`;
                container.appendChild(div);
            }
        });
        if(!hasItems) container.innerHTML = '<div style="font-size:0.8rem; color:#888;">Win to collect!</div>';
    }

    function applyWinnerStyle(cell, prize) {
        const wrapper = cell.querySelector('.avatar-wrapper');
        if(wrapper) {
            wrapper.classList.add('winner-anim');
            const p = document.createElement('div');
            p.className = 'prize-popup';
            p.innerText = prize ? prize.icon : 'üéÅ';
            cell.appendChild(p);
        }
    }
    function applyLoserStyle(cell) {
        const wrapper = cell.querySelector('.avatar-wrapper');
        if(wrapper) {
            wrapper.classList.add('sinking-anim');
            wrapper.innerHTML += `<div class="tear" style="left:30%; animation-delay:0s"></div><div class="tear" style="left:70%; animation-delay:0.2s"></div>`;
            const p = document.createElement('div'); p.className = 'puddle'; cell.appendChild(p);
            const cloud = document.createElement('div'); cloud.className = 'rain-cloud'; cloud.innerText = 'üåßÔ∏è'; cell.appendChild(cloud);
            for(let i=0; i<3; i++) {
                const drop = document.createElement('div'); drop.className = 'rain-drop';
                drop.style.left = (20 + i*30) + '%'; drop.style.animationDelay = (i * 0.2) + 's';
                cell.appendChild(drop);
            }
        }
    }
</script>
</body>
</html>